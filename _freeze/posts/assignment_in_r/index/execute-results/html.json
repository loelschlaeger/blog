{
  "hash": "1dac8dba1eb8c091ab6baa7ff9dedb05",
  "result": {
    "markdown": "---\ntitle: \"Assignments in R\"\nsubtitle: \"The subtle differences between <- and =\"\ndate: \"2023-11-23\"\nimage: \"mail0.png\"\ndraft: true\ncategories: [R]\n---\n\n\nIn programming languages, an assignment is a fundamental concept where a value is assigned to a variable. This action establishes a relationship between the variable and the value, enabling the variable to be used as a representation of that value in subsequent operations within the program. \n\nR handles assignments in a way that's slightly unique. Assume we want to assign the value `3` to the variable `x`, there are two ways which look equivalent from the outside:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nx = 3\n```\n:::\n\n\nSo if they have the same effect, does it matter which you use?\n\n## A bit of history\n\nWhen R was first created, `<-` was the only choice of assignment operator. But R uses = for yet another purpose: associating function arguments with values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(1, mean = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9.451384\n```\n:::\n:::\n\n\nTo make things easier for new users familiar with languages like C, [R added the capability in 2001](https://developer.r-project.org/equalAssign.html) to also allow = be used as an assignment operator, on the basis that the intent (assignment or association) is usually clear by context.  \n\nSo, `x = 3` clearly means \"assign 3 to x\", whereas `f(x = 3)` clearly means \"call function f, setting the argument x to 3\".\n\n## Be aware of ambiguity\n\nIt’s because in R’s syntax the symbol = has two distinct meanings that get routinely conflated (even by experts, including in the documentation cited above):\n\nThe first meaning is as an assignment operator. This is all we’ve talked about so far.\nThe second meaning isn’t an operator but rather a syntax token that signals named argument passing in a function call. Unlike the = operator it performs no action at runtime, it merely changes the way an expression is parsed.\nSo how does R decide whether a given usage of = refers to the operator or to named argument passing? Let’s see.\n\nIn any piece of code of the general form …\n\n‹function_name›(‹argname› = ‹value›, …)\n‹function_name›(‹args›, ‹argname› = ‹value›, …)\n… the = is the token that defines named argument passing: it is not the assignment operator. Furthermore, = is entirely forbidden in some syntactic contexts:\n\nif (‹var› = ‹value›) …\nwhile (‹var› = ‹value›) …\nfor (‹var› = ‹value› in ‹value2›) …\nfor (‹var1› in ‹var2› = ‹value›) …\nAny of these will raise an error “unexpected '=' in ‹bla›”.\n\nIn any other context, = refers to the assignment operator call. In particular, merely putting parentheses around the subexpression makes any of the above (a) valid, and (b) an assignment.\n\n\n\nThere is one case where ambiguity might occur: if you wanted to assign a variable during a function call. The only way to do this in modern versions of R is:\n\nf(x <- 3)\n\nmedian((x = 1 : 10))\n\nThe difference in assignment operators is clearer when you use them to set an argument value in a function call. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x)\nmedian(x = 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n\n```{.r .cell-code}\nx   \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'x' not found\n```\n:::\n:::\n\n\nIn this case, x is declared within the scope of the function, so it does not exist in the user workspace.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(x <- 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n\n```{.r .cell-code}\nx    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nIn this case, x is declared in the user workspace, so you can use it after the function call has been completed.\n\n\nwhich means \"assign 3 to x, and call f with the first argument set to the value 3\".  This is a contrived example though, and never really occurs in real-world programming. \n\nNote that the spaces around the arrow help to clarify situations like `x<-3`:\n\n- Does this mean assignment `x <- 3`?\n\n- Or less than `x < -3`?\n\n## So what to do?\n\nSo, back to the original question: should you use = or <- for assignment?  It really boils down to preference.  Many people are more used to using = for assignment, and it's one less keystroke if you want to save on typing.  On the other hand, many R traditionalists prefer <- for clarity, and if you plan to share or publish your code, other might find code using = for assignment hard to read. Personally, I prefer the arrow notation, with a space on either side.\nSo, long story short: it's really up to you.\n\nThere is a general preference among the R community for using <- for assignment (other than in function signatures) for compatibility with (very) old versions of S-Plus. \n\nIf you prefer writing `=` to `<-` for assignments but want to use the more common assignment symbol for publicly released code (on CRAN, for example), then you can use one of the `tidy_*` functions in the [`{formatR}` package](https://github.com/yihui/formatR#readme) to automatically replace `=` with `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"formatR\")\ntidy_source(text = \"x=1:5\", arrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx <- 1:5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}